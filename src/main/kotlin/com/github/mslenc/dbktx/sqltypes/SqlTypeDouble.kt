package com.github.mslenc.dbktx.sqltypes

import com.github.mslenc.asyncdb.DbValue
import com.github.mslenc.asyncdb.impl.values.DbValueDouble
import com.github.mslenc.dbktx.util.Sql
import kotlin.reflect.KClass

class SqlTypeDouble(concreteType: SqlTypeKind,
                    isNotNull: Boolean,
                    isUnsigned: Boolean)

    : SqlTypeNumeric<Double>(isNotNull = isNotNull, isAutoGenerated = false, isUnsigned = isUnsigned) {

    private val minVal: Double
    private val maxVal: Double

    init {
        when (concreteType) {
            SqlTypeKind.FLOAT -> {
                this.minVal = if (isUnsigned) 0.0 else -Float.MAX_VALUE.toDouble()
                this.maxVal = Float.MAX_VALUE.toDouble()
            }

            SqlTypeKind.DOUBLE -> {
                this.minVal = if (isUnsigned) 0.0 else -Double.MAX_VALUE
                this.maxVal = Double.MAX_VALUE
            }

            else -> throw IllegalArgumentException("Unsupported type $concreteType")
        }
    }

    override fun parseDbValue(value: DbValue): Double {
        return value.asDouble()
    }

    override fun makeDbValue(value: Double): DbValue {
        return DbValueDouble(value)
    }

    override fun encodeForJson(value: Double): Any {
        return value
    }

    override fun decodeFromJson(value: Any): Double {
        if (value is Number)
            return value.toDouble()

        throw IllegalArgumentException("Not a number: $value")
    }

    override fun toSql(value: Double, sql: Sql) {
        sql(value)
    }

    override val dummyValue: Double = 2 * Math.PI

    override val kotlinType: KClass<Double> = Double::class

    companion object {
        val INSTANCE_FOR_AVG = SqlTypeDouble(SqlTypeKind.DOUBLE, isNotNull = false, isUnsigned = false)
    }
}
