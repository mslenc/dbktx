package com.xs0.dbktx

import com.xs0.dbktx.sqltypes.SqlType
import java.util.*

open class Column<E : DbEntity<E, *>, TYPE : Any>(table: DbTable<E, *>, private val getter: (E) -> TYPE, dbName: String, val sqlType: SqlType<TYPE>, val indexInRow: Int) : RowProp<E, TYPE>(table, dbName) {

    override fun eq(value: TYPE): ExprBoolean<E> {
        return ExprEquals.equals(this, makeLiteral(value))
    }

    override fun neq(value: TYPE): ExprBoolean<E> {
        return ExprEquals.notEquals(this, makeLiteral(value))
    }

    infix fun lt(other: TYPE): ExprBoolean<E> {
        return ExprRel(this, Rel.LESS, makeLiteral(other))
    }

    infix fun lte(other: TYPE): ExprBoolean<E> {
        return ExprRel(this, Rel.LESS_OR_EQUAL, makeLiteral(other))
    }

    infix fun gt(other: TYPE): ExprBoolean<E> {
        return ExprRel(this, Rel.GREATER, makeLiteral(other))
    }

    infix fun gte(other: TYPE): ExprBoolean<E> {
        return ExprRel(this, Rel.GREATER_OR_EQUAL, makeLiteral(other))
    }

    fun oneOf(vararg values: TYPE): ExprBoolean<E> {
        if (values.isEmpty())
            throw IllegalArgumentException("No values")

        return oneOf(HashSet(Arrays.asList(*values)))
    }

    override infix fun oneOf(values: Set<TYPE>): ExprBoolean<E> {
        if (values.isEmpty())
            throw IllegalArgumentException("No values")

        val list = ArrayList<Expr<in E, TYPE>>()
        for (value in values)
            list.add(makeLiteral(value))
        return ExprOneOf.oneOf(this, list)
    }

    fun makeLiteral(value: TYPE): Literal<TYPE> {
        return Literal(value, sqlType)
    }

    override fun from(row: List<Any?>): TYPE? {
        val value = row[indexInRow] ?: return null

        return sqlType.fromJson(value)
    }

    fun from(entity: E): TYPE {
        return getter(entity)
    }

    override val isAutoGenerated = sqlType.isAutoGenerated

    override fun isSet(values: Map<Column<E, *>, Expr<in E, *>>): Boolean {
        return values[this] != null
    }
}

class SColumn<E : DbEntity<E, *>>(table: DbTable<E, *>, getter: (E) -> String, dbName: String, sqlType: SqlType<String>, indexInRow: Int) : Column<E, String>(table, getter, dbName, sqlType, indexInRow), ExprString<E> {

    fun like(pattern: String, escapeChar: Char): ExprBoolean<E> {
        return ExprLike(this, makeLiteral(pattern), escapeChar)
    }
}