package com.xs0.dbktx

import com.xs0.dbktx.sqltypes.SqlType
import java.lang.reflect.ParameterizedType
import java.math.BigDecimal
import java.time.*
import java.util.*
import java.util.function.*

class DbTableBuilder<E : DbEntity<E, ID>, ID> internal constructor(protected val table: DbTable<E, ID>) {
    protected val foreignKeys = HashMap<String, ForeignKey<*,*>>()

    fun build(constructor: BiFunction<ID, List<Any>, E>): DbTable<E, ID> {
        table.constructor = constructor

        val columnNames = StringBuilder()
        var i = 0
        val n = table.columns.size
        while (i < n) {
            if (i > 0)
                columnNames.append(", ")
            columnNames.append(table.columns[i].dbName)
            i++
        }
        table.columnNames = columnNames.toString()

        return table.validate()
    }

    private fun addSColumn(getter: (E) -> String, fieldNameInDb: String, sqlType: SqlType<String>, fieldProps: FieldProps): SColumn<E> {
        val column = SColumn(table, getter, fieldNameInDb, sqlType, table.columns.size)
        finishAddColumn(column, fieldProps)
        return column
    }

    private fun <TYPE> addColumn(getter: (E) -> TYPE, fieldNameInDb: String, sqlType: SqlType<TYPE>, fieldProps: FieldProps): Column<E, TYPE> {
        val column = Column(table, getter, fieldNameInDb, sqlType, table.columns.size)
        finishAddColumn(column, fieldProps)
        return column
    }

    private fun <TYPE> finishAddColumn(column: Column<E, TYPE>, fieldProps: FieldProps) {
        val actualClass = column.sqlType.javaType

        if (fieldProps.isAutoIncrement) {
            if (!fieldProps.isPrimaryKey)
                throw IllegalArgumentException("To be auto_increment, the column must be a primary key")
            table.keyIsAutogenerated = true
        }

        if (fieldProps.isPrimaryKey)
            setIdField(column, actualClass)

        if (fieldProps.foreignKey != null)
            foreignKeys.put(column.dbName, fieldProps.foreignKey)

        if (table.columnsByDbName.put(column.dbName, column) != null)
            throw IllegalArgumentException("A column named " + column.dbName + " already exists")

        table.columns.add(column)
    }

    private fun <T> setIdField(idField: RowProp<E, T>, actualClass: Class<T>) {
        if (!table.idClass.isAssignableFrom(actualClass))
            throw IllegalStateException("ID type mismatch in table " + table.dbName + " -- expected " + table.idClass + ", but actual is " + actualClass)

        val casted = idField as RowProp<E, ID>

        setIdField(casted)
    }

    protected fun setIdField(idField: RowProp<E, ID>) {
        if (table.idField != null)
            throw IllegalStateException("ID column is already set for table " + table.dbName)

        table.idField = idField
    }

    fun stringCol(fieldNameInDb: String, getter: Function<E, String>, typeDef: SqlTypeDef, vararg props: FieldProp): SColumn<E> {
        val fieldProps = make(props, "String", table.defaultCollation, COLLATE)

        val sqlType = SqlTypes.makeString(typeDef.sqlTypeKind, typeDef.param1, fieldProps)

        return addSColumn(getter, fieldNameInDb, sqlType, fieldProps)
    }

    fun <ENUM : Enum<ENUM>> enumIntCol(fieldNameInDb: String, getter: Function<E, ENUM>, klass: Class<ENUM>, toDbRep: ToIntFunction<ENUM>, fromDbRep: IntFunction<ENUM>, typeDef: SqlTypeDef, vararg props: FieldProp): Column<E, ENUM> {
        val fieldProps = make(props, "enumInt", UNSIGNED)

        val sqlType = SqlTypes.makeEnumToInt(typeDef.sqlTypeKind, klass, toDbRep, fromDbRep, fieldProps)

        return addColumn(getter, fieldNameInDb, sqlType, fieldProps)
    }

    fun stringCol(fieldNameInDb: String, getter: Function<E, String>, enumDef: EnumDef, vararg props: FieldProp): Column<E, String> {
        val fieldProps = make(props, "String", table.defaultCollation, COLLATE)

        val sqlType = SqlTypes.makeEnumString(enumDef, fieldProps)

        return addColumn(getter, fieldNameInDb, sqlType, fieldProps)
    }

    fun intCol(fieldNameInDb: String, getter: Function<E, Int>, typeDef: SqlTypeDef, vararg props: FieldProp): Column<E, Int> {
        val fieldProps = make(props, "Integer", UNSIGNED, AUTO_GENERATED)

        val sqlType = SqlTypes.makeInteger(typeDef.sqlTypeKind, fieldProps)

        return addColumn(getter, fieldNameInDb, sqlType, fieldProps)
    }

    fun longCol(fieldNameInDb: String, getter: Function<E, Long>, typeDef: SqlTypeDef, vararg props: FieldProp): Column<E, Long> {
        val fieldProps = make(props, "Long", UNSIGNED)

        val sqlType = SqlTypes.makeLong(typeDef.sqlTypeKind, fieldProps)

        return addColumn(getter, fieldNameInDb, sqlType, fieldProps)
    }

    fun boolCol(fieldNameInDb: String, getter: Function<E, Boolean>, typeDef: SqlTypeDef, vararg props: FieldProp): Column<E, Boolean> {
        val fieldProps = make(props, "Boolean", INT_AS_BOOL_VALUE_DEF)

        val sqlType = SqlTypes.makeBoolean(typeDef.sqlTypeKind, fieldProps)

        return addColumn(getter, fieldNameInDb, sqlType, fieldProps)
    }

    fun dateTimeCol(fieldNameInDb: String, getter: Function<E, LocalDateTime>, typeDef: SqlTypeDef, vararg props: FieldProp): Column<E, LocalDateTime> {
        val fieldProps = make(props, "LocalDateTime")

        val sqlType = SqlTypes.makeLocalDateTime(typeDef.sqlTypeKind, fieldProps)

        return addColumn(getter, fieldNameInDb, sqlType, fieldProps)
    }

    fun instantCol(fieldNameInDb: String, getter: Function<E, Instant>, typeDef: SqlTypeDef, vararg props: FieldProp): Column<E, Instant> {
        val fieldProps = make(props, "Instant")

        val sqlType = SqlTypes.makeInstant(typeDef.sqlTypeKind, fieldProps)

        return addColumn(getter, fieldNameInDb, sqlType, fieldProps)
    }

    fun dateCol(fieldNameInDb: String, getter: Function<E, LocalDate>, typeDef: SqlTypeDef, vararg props: FieldProp): Column<E, LocalDate> {
        val fieldProps = make(props, "LocalDate")

        val sqlType = SqlTypes.makeLocalDate(typeDef.sqlTypeKind, fieldProps)

        return addColumn(getter, fieldNameInDb, sqlType, fieldProps)
    }

    fun timeCol(fieldNameInDb: String, getter: Function<E, LocalTime>, typeDef: SqlTypeDef, vararg props: FieldProp): Column<E, LocalTime> {
        val fieldProps = make(props, "LocalTime")

        val sqlType = SqlTypes.makeLocalTime(typeDef.sqlTypeKind, fieldProps)

        return addColumn(getter, fieldNameInDb, sqlType, fieldProps)
    }

    fun yearCol(fieldNameInDb: String, getter: Function<E, Year>, typeDef: SqlTypeDef, vararg props: FieldProp): Column<E, Year> {
        val fieldProps = make(props, "Year")

        val sqlType = SqlTypes.makeYear(typeDef.sqlTypeKind, fieldProps)

        return addColumn(getter, fieldNameInDb, sqlType, fieldProps)
    }

    fun floatCol(fieldNameInDb: String, getter: Function<E, Float>, typeDef: SqlTypeDef, vararg props: FieldProp): Column<E, Float> {
        val fieldProps = make(props, "Float", UNSIGNED)

        val sqlType = SqlTypes.makeFloat(typeDef.sqlTypeKind, fieldProps)

        return addColumn(getter, fieldNameInDb, sqlType, fieldProps)
    }

    fun doubleCol(fieldNameInDb: String, getter: Function<E, Double>, typeDef: SqlTypeDef, vararg props: FieldProp): Column<E, Double> {
        val fieldProps = make(props, "Double", UNSIGNED)

        val sqlType = SqlTypes.makeDouble(typeDef.sqlTypeKind, fieldProps)

        return addColumn(getter, fieldNameInDb, sqlType, fieldProps)
    }

    fun decimalCol(fieldNameInDb: String, getter: Function<E, BigDecimal>, typeDef: SqlTypeDef, vararg props: FieldProp): Column<E, BigDecimal> {
        val fieldProps = make(props, "BigDecimal", UNSIGNED)

        val precision = typeDef.param1
        val scale = typeDef.param2

        val sqlType = SqlTypes.makeBigDecimal(typeDef.sqlTypeKind, precision!!, scale!!, fieldProps)

        return addColumn(getter, fieldNameInDb, sqlType, fieldProps)
    }

    fun blobCol(fieldNameInDb: String, getter: Function<E, ByteArray>, typeDef: SqlTypeDef, vararg props: FieldProp): Column<E, ByteArray> {
        val fieldProps = make(props, "byte[]")

        val sqlType = SqlTypes.makeByteArray(typeDef.sqlTypeKind, typeDef.param1, fieldProps)

        return addColumn(getter, fieldNameInDb, sqlType, fieldProps)
    }

    fun uuidCol(fieldNameInDb: String, getter: Function<E, UUID>, typeDef: SqlTypeDef, vararg props: FieldProp): Column<E, UUID> {
        val fieldProps = make(props, "UUID")

        val sqlType = SqlTypes.makeUUID(typeDef.sqlTypeKind, typeDef.param1!!, fieldProps)

        return addColumn(getter, fieldNameInDb, sqlType, fieldProps)
    }

    internal fun dummyRow(): List<Any> {
        return dummyRow(table.columns)
    }

    fun <COL : Column<E, TID>, TARGET : DbEntity<TARGET, TID>, TID> relToOne(sourceColumn: COL): RelToOne<E, TARGET> {
        val foreignKey = foreignKeys[sourceColumn.dbName] ?: throw IllegalArgumentException("Missing foreign key info for column " + sourceColumn.dbName)

        return this.relToOne(sourceColumn, foreignKey.foreignClass as Class<TARGET>)
    }

    fun <TARGET : DbEntity<TARGET, TID>, TID : CompositeId2<TARGET, A, B, TID>, A, B> relToOne(columnA: Column<E, A>, columnB: Column<E, B>, targetClass: Class<TARGET>): RelToOne<E, TARGET> {
        return relToOne(columnA, columnB, targetClass, null)
    }

    fun <TARGET : DbEntity<TARGET, TID>, TID : CompositeId2<TARGET, A, B, TID>, A, B> relToOne(columnA: Column<E, A>, columnB: Column<E, B>, targetClass: Class<TARGET>, idConstructor: BiFunction<A, B, TID>?): RelToOne<E, TARGET> {
        val result = RelToOneImpl<E, ID, TARGET, TID>()
        table.schema.addLazyInit(PRIORITY_REL_TO_ONE) {
            val targetTable = table.schema.getTableFor(targetClass)
            val targetIdColumns = targetTable.idField as MultiColumn<TARGET, TID>
            val targetId = targetIdColumns.from(dummyRow(targetTable.columns))

            val fields = arrayOfNulls<ColumnMapping<*, *, *>>(2)

            fields[0] = ColumnMapping(columnA, targetId.columnA)
            fields[1] = ColumnMapping(columnB, targetId.columnB)

            val info = ManyToOneInfo<E, ID, TARGET, TID>(table, targetTable, fields)

            val idCons: Function<E, TID>
            if (idConstructor != null) {
                idCons = { source -> idConstructor.apply(columnA.from(source), columnB.from(source)) }
            } else {
                idCons = info.makeForwardMapper()
            }

            result.init(info, idCons)
        }
        return result
    }

    fun <TARGET : DbEntity<TARGET, TID>, TID> relToOne(sourceField: Column<E, TID>, targetClass: Class<TARGET>): RelToOne<E, TARGET> {
        val result = RelToOneImpl<E, ID, TARGET, TID>()
        table.schema.addLazyInit(PRIORITY_REL_TO_ONE) {
            val targetTable = table.schema.getTableFor(targetClass)

            if (!targetTable.idClass.isAssignableFrom(sourceField.sqlType.javaType))
                throw IllegalStateException("Type mismatch on relToOne mapping for table " + table.dbName)

            val fields = arrayOfNulls<ColumnMapping<*, *, *>>(1)

            val field0 = ColumnMapping(sourceField, targetTable.idField as Column<*, *>)

            fields[0] = field0

            val info = ManyToOneInfo<E, ID, TARGET, TID>(table, targetTable, fields)

            result.init(info) { sourceField.from(it) }
        }
        return result
    }

    fun <TARGET : DbEntity<TARGET, TID>, TID> relToMany(oppositeRel: Supplier<RelToOne<TARGET, E>>): RelToMany<E, TARGET> {
        val rel = RelToManyImpl<E, ID, TARGET, TID>()
        table.schema.addLazyInit(PRIORITY_REL_TO_MANY) {
            val relToOne = oppositeRel.get() as RelToOneImpl<TARGET, TID, E, ID>
            val info = relToOne.info
            rel.init(info, relToOne.idMapper, info.makeReverseQueryBuilder())
        }
        return rel
    }

    fun <CTX> withContext(klass: Class<CTX>): WithContext<E, ID, CTX> {
        return table.getOrCreateContext(klass)
    }

    fun onInsert(insertModifier: Consumer<DbInsert<E, ID>>) {
        Objects.requireNonNull(insertModifier)
        table.getOrCreateContext<Any>(null).onInsert { insert, noCtx -> insertModifier.accept(insert) }
    }

    fun onUpdate(updateModifier: Consumer<DbUpdate<E>>) {
        Objects.requireNonNull(updateModifier)
        table.getOrCreateContext<Any>(null).onUpdate { update, ctx -> updateModifier.accept(update) }
    }

    companion object {

        protected val PRIORITY_COLUMNS = 0
        protected val PRIORITY_REL_TO_ONE = 1
        protected val PRIORITY_REL_TO_MANY = 2

        internal fun <E : DbEntity<E, *>> dummyRow(columns: ArrayList<Column<E, *>>): List<Any> {
            val res = ArrayList<Any>()

            for (column in columns)
                addDummy<*>(column.sqlType, res)

            return res
        }

        internal fun <T> addDummy(sqlType: SqlType<T>, out: MutableList<Any>) {
            out.add(sqlType.toJson(sqlType.dummyValue()))
        }

        fun <E : DbEntity<E, ID>, ID> determineIdClass(entityClass: Class<E>): Class<ID> {
            val type = entityClass.genericSuperclass
            if (type is Class<*>) {
                return determineIdClass<DbEntity, Any>(type)
            }

            if (type is ParameterizedType) {
                if (type.rawType === DbEntity<*, *>::class.java) {
                    return type.actualTypeArguments[1] as Class<ID>
                }
            }

            throw IllegalStateException("Can't determine ID type of " + entityClass)
        }
    }
}
