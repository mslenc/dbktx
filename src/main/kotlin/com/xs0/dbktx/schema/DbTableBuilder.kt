package com.xs0.dbktx.schema

import com.xs0.dbktx.composite.CompositeId
import com.xs0.dbktx.sqltypes.SqlType
import com.xs0.dbktx.sqltypes.SqlTypes
import java.math.BigDecimal
import java.time.*
import kotlin.reflect.KClass
import kotlin.reflect.full.isSubclassOf
import com.xs0.dbktx.composite.CompositeId2
import com.xs0.dbktx.composite.CompositeId3
import com.xs0.dbktx.conn.DbConn
import com.xs0.dbktx.fieldprops.SqlTypeDef
import com.xs0.dbktx.sqltypes.SqlTypeKind
import java.util.*

typealias Ref<T> = KClass<out DbEntity<*, T>>

open class DbTableBuilder<E : DbEntity<E, ID>, ID : Any>
internal constructor(
        protected val table: DbTable<E, ID>) {

    private val foreignKeys = HashMap<String, KClass<out DbEntity<*, *>>>()
    private var idFieldInitialized: Boolean = false

    fun build(factory: (DbConn, ID, List<Any?>) -> E): DbTable<E, ID> {
        table.factory = factory

        val columnNames = StringBuilder()
        var i = 0
        val n = table.columns.size
        while (i < n) {
            if (i > 0)
                columnNames.append(", ")
            columnNames.append(table.columns[i].fieldName)
            i++
        }
        table.columnNames = columnNames.toString()

        return table.validate()
    }

    fun nonNullString(fieldName: String, type: SqlTypeDef, getter: (E) -> String,
                      primaryKey: Boolean = false,
                      references: Ref<String>? = null): NonNullStringColumn<E> {

        val sqlType = SqlTypes.makeString(type.sqlTypeKind, type.param1, true)
        val column = NonNullStringColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = primaryKey, isAutoIncrement = false)
        return column
    }

    fun nullableString(fieldName: String, type: SqlTypeDef, getter: (E) -> String?,
                       references: Ref<String>? = null): NullableStringColumn<E> {

        val sqlType = SqlTypes.makeString(type.sqlTypeKind, type.param1, false)
        val column = NullableStringColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = false, isAutoIncrement = false)
        return column
    }



    fun nonNullInt(fieldName: String, type: SqlTypeDef, getter: (E) -> Int,
                   primaryKey: Boolean? = null,
                   autoIncrement: Boolean = false,
                   unsigned: Boolean = false,
                   references: Ref<Int>? = null): NonNullOrderedColumn<E, Int> {

        val sqlType = SqlTypes.makeInteger(type.sqlTypeKind, isNotNull = true, isAutoGenerated = autoIncrement, isUnsigned = unsigned)
        val column = NonNullOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = primaryKey ?: autoIncrement, isAutoIncrement = autoIncrement)
        return column
    }

    fun nullableInt(fieldName: String, type: SqlTypeDef, getter: (E) -> Int?,
                    unsigned: Boolean = false,
                    references: Ref<Int>? = null): NullableOrderedColumn<E, Int> {

        val sqlType = SqlTypes.makeInteger(type.sqlTypeKind, isNotNull = false, isAutoGenerated = false, isUnsigned = unsigned)
        val column = NullableOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references)
        return column
    }



    fun nonNullLong(fieldName: String, type: SqlTypeDef, getter: (E) -> Long,
                    primaryKey: Boolean? = null,
                    autoIncrement: Boolean = false,
                    unsigned: Boolean = false,
                    references: Ref<Long>? = null): NonNullOrderedColumn<E, Long> {

        val sqlType = SqlTypes.makeLong(type.sqlTypeKind, isNotNull = true, isAutoGenerated = autoIncrement, isUnsigned = unsigned)
        val column = NonNullOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = primaryKey ?: autoIncrement, isAutoIncrement = autoIncrement)
        return column
    }

    fun nullableLong(fieldName: String, type: SqlTypeDef, getter: (E) -> Long,
                     unsigned: Boolean = false,
                     references: Ref<Long>? = null): NullableOrderedColumn<E, Long> {

        val sqlType = SqlTypes.makeLong(type.sqlTypeKind, isNotNull = false, isAutoGenerated = false, isUnsigned = unsigned)
        val column = NullableOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = false, isAutoIncrement = false)
        return column
    }



    fun nonNullFloat(fieldName: String, type: SqlTypeDef, getter: (E) -> Float,
                     primaryKey: Boolean = false,
                     unsigned: Boolean = false,
                     references: Ref<Float>? = null): NonNullOrderedColumn<E, Float> {

        val sqlType = SqlTypes.makeFloat(type.sqlTypeKind, isNotNull = true, isUnsigned = unsigned)
        val column = NonNullOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = primaryKey)
        return column
    }

    fun nullableFloat(fieldName: String, type: SqlTypeDef, getter: (E) -> Float?,
                      unsigned: Boolean = false,
                      references: Ref<Float>? = null): NullableOrderedColumn<E, Float> {

        val sqlType = SqlTypes.makeFloat(type.sqlTypeKind, isNotNull = false, isUnsigned = unsigned)
        val column = NullableOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references)
        return column
    }



    fun nonNullDouble(fieldName: String, type: SqlTypeDef, getter: (E) -> Double,
                      primaryKey: Boolean = false,
                      unsigned: Boolean = false,
                      references: Ref<Double>? = null): NonNullOrderedColumn<E, Double> {

        val sqlType = SqlTypes.makeDouble(type.sqlTypeKind, isNotNull = true, isUnsigned = unsigned)
        val column = NonNullOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = primaryKey)
        return column
    }

    fun nullableDouble(fieldName: String, type: SqlTypeDef, getter: (E) -> Double?,
                       unsigned: Boolean = false,
                       references: Ref<Double>? = null): NullableOrderedColumn<E, Double> {

        val sqlType = SqlTypes.makeDouble(type.sqlTypeKind, isNotNull = false, isUnsigned = unsigned)
        val column = NullableOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references)
        return column
    }


    fun nonNullUUID(fieldName: String, type: SqlTypeDef, getter: (E) -> UUID,
                    primaryKey: Boolean = false,
                    references: Ref<UUID>? = null): NonNullColumn<E, UUID> {

        val size = type.param1 ?: throw IllegalArgumentException("Missing size for UUID type")
        val sqlType = SqlTypes.makeUUID(type.sqlTypeKind, size = size, isNotNull = true)
        val column = NonNullColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = primaryKey)
        return column
    }

    fun nullableUUID(fieldName: String, type: SqlTypeDef, getter: (E) -> UUID?,
                     references: Ref<UUID>? = null): NullableColumn<E, UUID> {

        val size = type.param1 ?: throw IllegalArgumentException("Missing size for UUID type")
        val sqlType = SqlTypes.makeUUID(type.sqlTypeKind, size = size, isNotNull = false)
        val column = NullableColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references)
        return column
    }



    fun nonNullYear(fieldName: String, type: SqlTypeDef, getter: (E) -> Year,
                    primaryKey: Boolean = false,
                    references: Ref<Year>? = null): NonNullOrderedColumn<E, Year> {

        val sqlType = SqlTypes.makeYear(type.sqlTypeKind, isNotNull = true)
        val column = NonNullOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = primaryKey)
        return column
    }

    fun nullableYear(fieldName: String, type: SqlTypeDef, getter: (E) -> Year?,
                     references: Ref<Year>? = null): NullableOrderedColumn<E, Year> {

        val sqlType = SqlTypes.makeYear(type.sqlTypeKind, isNotNull = false)
        val column = NullableOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references)
        return column
    }



    fun nonNullDateTime(fieldName: String, type: SqlTypeDef, getter: (E) -> LocalDateTime,
                        primaryKey: Boolean = false,
                        references: Ref<LocalDateTime>? = null): NonNullOrderedColumn<E, LocalDateTime> {

        val sqlType = SqlTypes.makeLocalDateTime(type.sqlTypeKind, isNotNull = true)
        val column = NonNullOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = primaryKey)
        return column
    }

    fun nullableDateTime(fieldName: String, type: SqlTypeDef, getter: (E) -> LocalDateTime?,
                         references: Ref<LocalDateTime>? = null): NullableOrderedColumn<E, LocalDateTime> {

        val sqlType = SqlTypes.makeLocalDateTime(type.sqlTypeKind, isNotNull = false)
        val column = NullableOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references)
        return column
    }


    fun nonNullInstant(fieldName: String, type: SqlTypeDef, getter: (E) -> Instant,
                       primaryKey: Boolean = false,
                       references: Ref<Instant>? = null): NonNullOrderedColumn<E, Instant> {

        val sqlType = SqlTypes.makeInstant(type.sqlTypeKind, isNotNull = true)
        val column = NonNullOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = primaryKey)
        return column
    }

    fun nullableInstant(fieldName: String, type: SqlTypeDef, getter: (E) -> Instant?,
                        references: Ref<Instant>? = null): NullableOrderedColumn<E, Instant> {

        val sqlType = SqlTypes.makeInstant(type.sqlTypeKind, isNotNull = false)
        val column = NullableOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references)
        return column
    }


    fun nonNullTime(fieldName: String, type: SqlTypeDef, getter: (E) -> LocalTime,
                    primaryKey: Boolean = false,
                    references: Ref<LocalTime>? = null): NonNullOrderedColumn<E, LocalTime> {

        val sqlType = SqlTypes.makeLocalTime(type.sqlTypeKind, isNotNull = true)
        val column = NonNullOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = primaryKey)
        return column
    }

    fun nullableTime(fieldName: String, type: SqlTypeDef, getter: (E) -> LocalTime?,
                     references: Ref<LocalTime>? = null): NullableOrderedColumn<E, LocalTime> {

        val sqlType = SqlTypes.makeLocalTime(type.sqlTypeKind, isNotNull = false)
        val column = NullableOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references)
        return column
    }


    fun nonNullDate(fieldName: String, type: SqlTypeDef, getter: (E) -> LocalDate,
                    primaryKey: Boolean = false,
                    references: Ref<LocalDate>? = null): NonNullOrderedColumn<E, LocalDate> {

        val sqlType = SqlTypes.makeLocalDate(type.sqlTypeKind, isNotNull = true)
        val column = NonNullOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = primaryKey)
        return column
    }

    fun nullableDate(fieldName: String, type: SqlTypeDef, getter: (E) -> LocalDate?,
                     references: Ref<LocalDate>? = null): NullableOrderedColumn<E, LocalDate> {

        val sqlType = SqlTypes.makeLocalDate(type.sqlTypeKind, isNotNull = false)
        val column = NullableOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references)
        return column
    }


    fun nonNullBytes(fieldName: String, type: SqlTypeDef, getter: (E) -> ByteArray)
            : NonNullColumn<E, ByteArray> {

        val sqlType = SqlTypes.makeByteArray(type.sqlTypeKind, type.param1, isNotNull = true)
        val column = NonNullColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, foreignKey = null)
        return column
    }

    fun nullableBytes(fieldName: String, type: SqlTypeDef, getter: (E) -> ByteArray?)
            : NullableColumnImpl<E, ByteArray> {

        val sqlType = SqlTypes.makeByteArray(type.sqlTypeKind, type.param1, isNotNull = false)
        val column = NullableColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, foreignKey = null)
        return column
    }


    fun nonNullDecimal(fieldName: String, type: SqlTypeDef, getter: (E) -> BigDecimal,
                       primaryKey: Boolean = false,
                       unsigned: Boolean = false,
                       references: Ref<BigDecimal>? = null): NonNullOrderedColumn<E, BigDecimal> {

        val precision: Int = type.param1 ?: throw IllegalArgumentException("Missing precision for DECIMAL")
        val scale: Int = type.param2 ?: throw IllegalArgumentException("Missing scale for DECIMAL")

        val sqlType = SqlTypes.makeBigDecimal(type.sqlTypeKind, precision, scale, isNotNull = true, isUnsigned = unsigned)
        val column = NonNullOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = primaryKey)
        return column
    }

    fun nullableDecimal(fieldName: String, type: SqlTypeDef, getter: (E) -> BigDecimal?,
                        primaryKey: Boolean = false,
                        unsigned: Boolean = false,
                        references: Ref<BigDecimal>? = null): NullableOrderedColumn<E, BigDecimal> {

        val precision: Int = type.param1 ?: throw IllegalArgumentException("Missing precision for DECIMAL")
        val scale: Int = type.param2 ?: throw IllegalArgumentException("Missing scale for DECIMAL")

        val sqlType = SqlTypes.makeBigDecimal(type.sqlTypeKind, precision, scale, isNotNull = false, isUnsigned = unsigned)
        val column = NullableOrderedColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = primaryKey)
        return column
    }


    fun nonNullStringEnum(fieldName: String,
                          values: Set<String>,
                          getter: (E) -> String,
                          type: SqlTypeDef = SqlTypeDef(SqlTypeKind.ENUM),
                          primaryKey: Boolean = false,
                          references: Ref<String>? = null): NonNullColumn<E, String> {

        val sqlType = SqlTypes.makeEnumString(type.sqlTypeKind, values, isNotNull = true)
        val column = NonNullColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = primaryKey)
        return column
    }

    fun nullableStringEnum(fieldName: String,
                          values: Set<String>,
                          getter: (E) -> String?,
                          type: SqlTypeDef = SqlTypeDef(SqlTypeKind.ENUM),
                          references: Ref<String>? = null): NullableColumn<E, String> {

        val sqlType = SqlTypes.makeEnumString(type.sqlTypeKind, values, isNotNull = false)
        val column = NullableColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references)
        return column
    }


    inline fun <reified ENUM : Enum<ENUM>>
            nonNullIntEnum(fieldName: String,
                           typeDef: SqlTypeDef,
                           noinline getter: (E) -> ENUM,
                           noinline toDbRep: (ENUM)->Int,
                           noinline fromDbRep: (Int)->ENUM,
                           references: Ref<ENUM>? = null,
                           primaryKey: Boolean = false
                           ): NonNullColumn<E, ENUM> {

        val klass = ENUM::class
        val dummyValue = enumValues<ENUM>()[0]

        return nonNullIntEnum(fieldName, typeDef, getter, toDbRep, fromDbRep, klass, dummyValue, references, primaryKey = primaryKey)
    }

    fun <ENUM : Enum<ENUM>>
            nonNullIntEnum(fieldName: String,
                           typeDef: SqlTypeDef,
                           getter: (E) -> ENUM,
                           toDbRep: (ENUM)->Int,
                           fromDbRep: (Int)->ENUM,
                           klass: KClass<ENUM>,
                           dummyValue: ENUM,
                           references: Ref<ENUM>? = null,
                           primaryKey: Boolean = false
                           ): NonNullColumn<E, ENUM> {

        val sqlType = SqlTypes.makeEnumToInt(klass, dummyValue, typeDef.sqlTypeKind, toDbRep, fromDbRep, isNotNull = true)
        val column = NonNullColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references, isPrimaryKey = primaryKey)
        return column
    }

    inline fun <reified ENUM : Enum<ENUM>>
            nullableIntEnum(fieldName: String,
                            noinline getter: (E) -> ENUM?,
                            noinline toDbRep: (ENUM)->Int,
                            noinline fromDbRep: (Int)->ENUM,
                            typeDef: SqlTypeDef,
                            references: Ref<ENUM>? = null
                            ): NullableColumn<E, ENUM> {

        val klass = ENUM::class
        val dummyValue = enumValues<ENUM>()[0]

        return nullableIntEnum(fieldName, getter, toDbRep, fromDbRep, typeDef, klass, dummyValue, references)
    }

    fun <ENUM : Enum<ENUM>>
            nullableIntEnum(fieldName: String,
                            getter: (E) -> ENUM?,
                            toDbRep: (ENUM)->Int,
                            fromDbRep: (Int)->ENUM,
                            typeDef: SqlTypeDef,
                            klass: KClass<ENUM>,
                            dummyValue: ENUM,
                            references: Ref<ENUM>? = null
                            ): NullableColumn<E, ENUM> {

        val sqlType = SqlTypes.makeEnumToInt(klass, dummyValue, typeDef.sqlTypeKind, toDbRep, fromDbRep, isNotNull = true)
        val column = NullableColumnImpl(table, getter, fieldName, sqlType, table.columns.size)
        finishAddColumn(column, references)
        return column
    }



    private fun <T : Any> finishAddColumn(column: Column<E, T>, foreignKey: Ref<T>?, isPrimaryKey: Boolean = false, isAutoIncrement: Boolean = false) {
        if (isAutoIncrement) {
            if (!isPrimaryKey)
                throw IllegalArgumentException("To be auto_increment, the column must be a primary key")
            table.keyIsAutogenerated = true
        }

        if (isPrimaryKey) {
            if (column is NonNullRowProp<*, *>) {
                @Suppress("UNCHECKED_CAST")
                setIdField(column as NonNullRowProp<E, T>, column.sqlType.kotlinType)
            } else {
                throw IllegalArgumentException("Primary key must be non null")
            }
        }

        if (foreignKey != null) {
            foreignKeys.put(column.fieldName, foreignKey)
        }

        if (table.columnsByDbName.put(column.fieldName, column) != null)
            throw IllegalArgumentException("A column named " + column.fieldName + " already exists")

        table.columns.add(column)
    }

    protected fun <T : Any>
    setIdField(idField: NonNullRowProp<E, T>, actualClass: KClass<out T>) {
        if (!actualClass.isSubclassOf(table.idClass))
            throw IllegalStateException("ID type mismatch in table " + table.dbName + " -- expected " + table.idClass + ", but actual is " + actualClass)

        @Suppress("UNCHECKED_CAST")
        val casted = idField as NonNullRowProp<E, ID>

        if (idFieldInitialized)
            throw IllegalStateException("ID column is already set for table " + table.dbName)

        table.idField = casted
        idFieldInitialized = true
    }


    // TODO: boolean?


    internal fun dummyRow(): List<Any> {
        return dummyRow(table.columns)
    }

    fun <TARGET : DbEntity<TARGET, TID>, TID: Any>
    relToOne(sourceColumn: Column<E, TID>): RelToOne<E, TARGET> {
        val foreignKey = foreignKeys[sourceColumn.fieldName] ?: throw IllegalArgumentException("Missing foreign key info for column " + sourceColumn.fieldName)

        @Suppress("UNCHECKED_CAST")
        return this.relToOne(sourceColumn, foreignKey as KClass<TARGET>)
    }

    fun <TARGET : DbEntity<TARGET, TID>, TID: Any>
    relToOne(sourceField: Column<E, TID>, targetClass: KClass<TARGET>): RelToOne<E, TARGET> {
        val result = RelToOneImpl<E, ID, TARGET, TID>()
        table.schema.addLazyInit(PRIORITY_REL_TO_ONE) {
            val targetTable = table.schema.getTableFor(targetClass)

            if (!sourceField.sqlType.kotlinType.isSubclassOf(targetTable.idClass))
                throw IllegalStateException("Type mismatch on relToOne mapping for table " + table.dbName)

            @Suppress("UNCHECKED_CAST")
            val targetId = targetTable.idField as NonNullColumn<TARGET, TID>

            val fields: Array<ColumnMapping<E, TARGET, *>> = arrayOf(
                    ColumnMapping(sourceField, targetId)
            )

            val info = ManyToOneInfo(table, targetTable, fields)

            result.init(info, sourceField::invoke)
        }
        return result
    }

    fun <TARGET : DbEntity<TARGET, TID>, TID: Any>
    relToMany(oppositeRel: ()-> RelToOne<TARGET, E>): RelToMany<E, TARGET> {
        val rel = RelToManyImpl<E, ID, TARGET, TID>()
        table.schema.addLazyInit(PRIORITY_REL_TO_MANY) {
            @Suppress("UNCHECKED_CAST")
            val relToOne = oppositeRel() as RelToOneImpl<TARGET, TID, E, ID>
            val info = relToOne.info
            rel.init(info, relToOne.idMapper, info.makeReverseQueryBuilder())
        }
        return rel
    }

    fun <TARGET : DbEntity<TARGET, TID>, TID : CompositeId2<TARGET, A, B, TID>, A : Any, B : Any>
    relToOne(columnA: Column<E, A>, columnB: Column<E, B>, targetClass: KClass<TARGET>, idConstructor: ((A, B)->TID)? = null): RelToOne<E, TARGET> {
        val result = RelToOneImpl<E, ID, TARGET, TID>()
        table.schema.addLazyInit(PRIORITY_REL_TO_ONE) {
            val targetTable = table.schema.getTableFor(targetClass)
            @Suppress("UNCHECKED_CAST")
            val targetIdColumns = targetTable.idField as MultiColumn<TARGET, TID>
            val targetId = targetIdColumns(dummyRow(targetTable.columns))

            val fields: Array<ColumnMapping<E, TARGET, *>> = arrayOf(
                    ColumnMapping(columnA, targetId.column1),
                    ColumnMapping(columnB, targetId.column2)
            )

            val info = ManyToOneInfo(table, targetTable, fields)

            val idCons: (E)->TID?
            if (idConstructor != null) {
                idCons = { source ->
                    val valA = columnA(source)
                    val valB = columnB(source)
                    if (valA != null && valB != null) idConstructor(valA, valB) else null
                }
            } else {
                idCons = info.makeForwardMapper()
            }

            result.init(info, idCons)
        }
        return result
    }

    fun <TARGET : DbEntity<TARGET, TID>, TID : CompositeId3<TARGET, T1, T2, T3, TID>, T1: Any, T2: Any, T3: Any>
    relToOne(column1: Column<E, T1>, column2: Column<E, T2>, column3: Column<E, T3>, targetClass: KClass<TARGET>, idConstructor: ((T1, T2, T3)->TID)? = null): RelToOne<E, TARGET> {
        val result = RelToOneImpl<E, ID, TARGET, TID>()
        table.schema.addLazyInit(PRIORITY_REL_TO_ONE) {
            val targetTable = table.schema.getTableFor(targetClass)
            @Suppress("UNCHECKED_CAST")
            val targetIdColumns = targetTable.idField as MultiColumn<TARGET, TID>
            val targetId = targetIdColumns(dummyRow(targetTable.columns))

            val fields: Array<ColumnMapping<E, TARGET, *>> = arrayOf(
                    ColumnMapping(column1, targetId.column1),
                    ColumnMapping(column2, targetId.column2),
                    ColumnMapping(column3, targetId.column3)
            )

            val info = ManyToOneInfo(table, targetTable, fields)

            val idCons: (E)->TID?
            if (idConstructor != null) {
                idCons = { source ->
                    val val1 = column1(source)
                    val val2 = column2(source)
                    val val3 = column3(source)
                    if (val1 != null && val2 != null && val3 != null) idConstructor(val1, val2, val3) else null
                }
            } else {
                idCons = info.makeForwardMapper()
            }

            result.init(info, idCons)
        }
        return result
    }

    companion object {
        const val PRIORITY_REL_TO_ONE = 1
        const val PRIORITY_REL_TO_MANY = 2

        internal fun <E : DbEntity<E, *>> dummyRow(columns: ArrayList<Column<E, *>>): List<Any> {
            val res = ArrayList<Any>()

            for (column in columns)
                addDummy(column.sqlType, res)

            return res
        }

        private fun <T: Any> addDummy(sqlType: SqlType<T>, out: MutableList<Any>) {
            out.add(sqlType.toJson(sqlType.dummyValue))
        }
    }
}
