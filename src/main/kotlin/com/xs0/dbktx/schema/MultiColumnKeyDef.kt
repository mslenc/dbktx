package com.xs0.dbktx.schema

import com.xs0.dbktx.composite.CompositeId
import com.xs0.dbktx.crud.BoundMultiColumnForSelect
import com.xs0.dbktx.expr.*
import com.xs0.dbktx.crud.EntityValues
import com.xs0.dbktx.crud.TableInQuery
import com.xs0.dbktx.util.Sql

class MultiColumnKeyDef<E : DbEntity<E, *>, ID : CompositeId<E, ID>>(
        override val table: DbTable<E, *>,
        override val indexInTable: Int,
        private val constructor: (List<Any?>) -> ID,
        private val extractor: (E) -> ID,
        private val prototype: ID,
        override val isPrimaryKey: Boolean) : UniqueKeyDef<E, ID> {

    override val numColumns: Int
        get() = prototype.numColumns

    override fun makeLiteral(value: ID): Expr<E, ID> {
        return value
    }

    override fun getColumn(index: Int): NonNullColumn<E, *> {
        return prototype.getColumn(index)
    }

    override operator fun invoke(row: List<Any?>): ID {
        return constructor(row)
    }

    override fun invoke(entity: E): ID {
        return extractor(entity)
    }

    override val isAutoGenerated: Boolean
        get() = false

    override fun bindForSelect(tableInQuery: TableInQuery<E>): BoundMultiColumnForSelect<E, ID> {
        return BoundMultiColumnForSelect(this, tableInQuery)
    }

    override fun extract(values: EntityValues<E>): ID? {
        val numCols = prototype.tableMetainfo.numColumns

        val row = ArrayList<Any?>(numCols)
        for (i in 0 until numCols)
            row.add(null)

        for (i in 1..numColumns) {
            val part = getColumn(i)
            val value = part.extract(values) ?: return null
            row[part.indexInRow] = value
        }

        return invoke(row)
    }
}