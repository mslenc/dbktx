package com.xs0.dbktx.sqltypes

import com.xs0.dbktx.util.Sql
import kotlin.reflect.KClass

class SqlTypeLong(
        private val concreteType: SqlTypeKind,
        isNotNull: Boolean,
        isAutoGenerated: Boolean,
        isUnsigned: Boolean)

    : SqlTypeNumeric<Long>(isNotNull = isNotNull,
                           isAutoGenerated = isAutoGenerated,
                           isUnsigned = isUnsigned) {

    private val minVal: Long
    private val maxVal: Long

    init {
        when (concreteType) {
            SqlTypeKind.INT -> if (isUnsigned) {
                this.minVal = 0
                this.maxVal = 4_294_967_295L
            } else {
                this.minVal = Integer.MIN_VALUE.toLong()
                this.maxVal = Integer.MAX_VALUE.toLong()
            }

            SqlTypeKind.BIGINT -> {
                this.minVal = Long.MIN_VALUE
                this.maxVal = Long.MAX_VALUE
            }

            else ->
                throw IllegalArgumentException("Unsupported type $concreteType")
        }
    }

    override fun parseRowDataValue(value: Any): Long {
        if (value is Long)
            return value

        if (value is Number)
            return value.toLong()

        throw IllegalArgumentException("Not a long - $value")
    }

    override fun encodeForJson(value: Long): Any {
        return value
    }

    override fun decodeFromJson(value: Any): Long {
        return parseRowDataValue(value)
    }

    override fun toSql(value: Long, sql: Sql) {
        if (isUnsigned && concreteType === SqlTypeKind.BIGINT && value < 0) {
            sql.raw(java.lang.Long.toUnsignedString(value))
        } else {
            sql(value)
        }
    }

    override val dummyValue: Long = maxVal / 2

    override val kotlinType: KClass<Long> = Long::class
}