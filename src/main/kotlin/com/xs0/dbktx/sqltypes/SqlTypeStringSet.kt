package com.xs0.dbktx.sqltypes

import com.xs0.dbktx.util.Sql
import com.xs0.dbktx.util.StringSet
import com.xs0.dbktx.util.toStringSet
import kotlin.reflect.KClass

class SqlTypeStringSet(private val concreteType: SqlTypeKind,
                       private val surroundedWithCommas: Boolean,
                       isNotNull: Boolean)
    : SqlType<StringSet>(isNotNull = isNotNull, isAutoGenerated = false) {

    init {
        // TODO: check concreteType is varchar or an actual SET, maximum length, etc..
    }

    override fun parseRowDataValue(value: Any): StringSet {
        if (value is StringSet)
            return value

        if (value !is CharSequence)
            throw IllegalStateException("Not a string value: " + value.javaClass)

        var str = value.toString()

        if (surroundedWithCommas && str.startsWith(",") && str.endsWith(","))
            str = str.substring(1, str.length - 1)

        if (str.isEmpty())
            return StringSet()

        return str.split(",").toSet().toStringSet()
    }

    override fun encodeForJson(value: StringSet): String {
        val sb = StringBuilder()

        if (surroundedWithCommas)
            sb.append(',')

        var first = true

        value.forEach {
            if (first) {
                first = false
            } else {
                sb.append(',')
            }

            sb.append(it)
        }

        if (surroundedWithCommas)
            sb.append(',')

        return sb.toString()
    }

    override fun decodeFromJson(value: Any): StringSet {
        return parseRowDataValue(value)
    }

    override val dummyValue: StringSet
        get() = setOf("someValue").toStringSet()

    override val kotlinType: KClass<StringSet>
        get() = StringSet::class

    override fun toSql(value: StringSet, sql: Sql) {
        sql(encodeForJson(value))
    }
}
