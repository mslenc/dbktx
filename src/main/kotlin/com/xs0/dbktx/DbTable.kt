package com.xs0.dbktx

import io.vertx.core.json.JsonObject
import si.datastat.db.DbConn
import si.datastat.db.api.*
import si.datastat.db.api.str.DbCollation
import si.datastat.db.impl.DbInsertImpl
import si.datastat.db.impl.DbUpdateImpl
import si.datastat.db.impl.EntityQueryImpl
import java.util.*
import java.util.function.BiFunction
import kotlin.reflect.KClass

class DbTable<E : DbEntity<E, ID>, ID> internal constructor(val schema: DbSchema, val dbName: String, val entityClass: KClass<E>, internal val idClass: KClass<ID>, defaultCollation: DbCollation?) {
    val defaultCollation : DbCollation = defaultCollation ?: schema.defaultCollation

    internal val columns = ArrayList<Column<E, *>>()
    internal val columnsByDbName = HashMap<String, Column<E, *>>()

    internal var constructor: BiFunction<ID, List<Any>, E>? = null
    var idField: RowProp<E, ID>? = null
        internal set
    internal var columnNames: String? = null
    var isKeyAutogenerated: Boolean = false
        internal set

    override fun hashCode(): Int {
        return dbName.hashCode()
    }

    fun validate(): DbTable<E, ID> {
        if (constructor == null)
            throw IllegalStateException("Missing constructor for table " + dbName)
        if (idField == null)
            throw IllegalStateException("Missing idField for table " + dbName)

        // TODO
        return this
    }

    fun createId(row: List<Any>): ID {
        return idField!!.from(row)
    }

    fun create(id: ID, row: List<Any>): E {
        return constructor!!.apply(id, row)
    }

    fun columnNames(): String? {
        return columnNames
    }

    val numColumns: Int
        get() = columns.size

    fun newQuery(dbLoader: DbConn<*, *>): EntityQuery<E> {
        return EntityQueryImpl(this, dbLoader)
    }

    fun toJsonObject(entity: E): JsonObject {
        val result = JsonObject()

        for (column in columns) {
            toJson<*>(entity, column, result)
        }

        return result
    }

    private fun <T> toJson(entity: E, column: Column<E, T>, result: JsonObject) {
        val value = column.from(entity)

        if (value == null) {
            result.putNull(column.dbName)
        } else {
            result.put(column.dbName, column.sqlType.toJson(value))
        }
    }

    fun fromJson(jsonObject: JsonObject): E {
        val n = columns.size
        val values = arrayOfNulls<Any>(n)
        for (i in 0..n - 1) {
            val column = columns[i]
            val jsonValue = jsonObject.getValue(column.dbName)
            if (jsonValue != null) {
                values[column.indexInRow] = column.sqlType.fromJson(jsonValue)
            }
        }

        val row = Arrays.asList<Any>(*values)
        return create(createId(row), row)
    }

    fun <CTX, T> insertion(db: DbConn<CTX, T>): DbInsert<E, ID> {
        val insert = DbInsertImpl<E, ID>(db, this)

        val commonActions = contextActions.get(null)
        commonActions?.apply(insert, null)

        val ctxActions = getContextActions(db)
        ctxActions?.apply(insert, db.context)

        return insert
    }

    private fun <CTX> prepareUpdate(db: DbConn<CTX, *>, update: DbUpdateImpl<E, ID>): DbUpdate<E> {
        val commonActions = contextActions.get(null)
        commonActions?.apply(update, null)

        val ctxActions = getContextActions(db)
        ctxActions?.apply(update, db.context)

        return update
    }

    fun <CTX> updateAll(db: DbConn<CTX, *>): DbUpdate<E> {
        return prepareUpdate(db, DbUpdateImpl(db, this, null, null))
    }

    fun <CTX> update(db: DbConn<CTX, *>, filter: Expr<in E, Boolean>): DbUpdate<E> {
        return prepareUpdate(db, DbUpdateImpl(db, this, filter, null))
    }

    fun <CTX> update(db: DbConn<CTX, *>, entity: E): DbUpdate<E> {
        return updateById(db, entity.id)
    }

    fun <CTX> updateById(db: DbConn<CTX, *>, id: ID): DbUpdate<E> {
        val idsSet = setOf(id)
        val filter = idField!!.equalTo(id)
        val update = DbUpdateImpl(db, this, filter, idsSet)
        return prepareUpdate(db, update)
    }

    fun <CTX> update(db: DbConn<CTX, *>, vararg entities: E): DbUpdate<E> {
        return update(db, Arrays.asList(*entities))
    }

    fun <CTX> updateByIds(db: DbConn<CTX, *>, vararg ids: ID): DbUpdate<E> {
        val idsSet = HashSet(Arrays.asList(*ids))
        val filter = idField!!.oneOf(idsSet)
        val update = DbUpdateImpl(db, this, filter, idsSet)
        return prepareUpdate(db, update)
    }

    fun <CTX> update(db: DbConn<CTX, *>, entities: Collection<E>): DbUpdate<E> {
        val idsSet = HashSet<ID>()
        for (entity in entities)
            idsSet.add(entity.id)

        val filter = idField!!.oneOf(idsSet)
        val update = DbUpdateImpl(db, this, filter, idsSet)
        return prepareUpdate(db, update)
    }

    fun <CTX> updateByIds(db: DbConn<CTX, *>, ids: Collection<ID>): DbUpdate<E> {
        val idsSet = HashSet(ids)
        val filter = idField!!.oneOf(idsSet)
        val update = DbUpdateImpl(db, this, filter, idsSet)
        return prepareUpdate(db, update)
    }

    private fun <CTX> getContextActions(db: DbConn<CTX, *>): WithContext<E, ID, CTX>? {
        val ctx = db.context ?: return null

        return contextActions[ctx.javaClass] as WithContext<E, ID, CTX>
    }
}